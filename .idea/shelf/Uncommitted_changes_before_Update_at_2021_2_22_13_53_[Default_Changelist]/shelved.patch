Index: note/gupao/15 有序树/01 提示词  [208]/Trie.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// *****************************************************写这个********************************************************\r\nclass TrieNode {\r\n    char c;\r\n    Map<Character, TrieNode> children = new HashMap<>();\r\n    boolean hashWord;\r\n    public TrieNode() {\r\n\r\n    }\r\n\r\n    public TrieNode(char c) {\r\n        this.c = c;\r\n    }\r\n}\r\nclass Trie {\r\n    TrieNode root;\r\n    /** Initialize your data structure here. */\r\n    public Trie() {\r\n        this.root = new TrieNode();\r\n    }\r\n\r\n    /** Inserts a word into the trie. */\r\n    public void insert(String word) {\r\n        TrieNode current = root;\r\n        Map<Character, TrieNode> children = current.children;\r\n        char[] arr = word.toCharArray();\r\n        for (int i = 0; i < word.length(); i++) {\r\n            if (!children.containsKey(arr[i])) {\r\n                TrieNode node = new TrieNode(arr[i]);\r\n                current = node;\r\n                children.put(arr[i], node);\r\n            } else {\r\n                TrieNode node = children.get(arr[i]);\r\n                current = node;\r\n            }\r\n            children = current.children;\r\n            if (i == arr.length - 1) {\r\n                current.hashWord = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Returns if the word is in the trie. */\r\n    public boolean search(String word) {\r\n        TrieNode current = root;\r\n        Map<Character, TrieNode> children = current.children;\r\n        char[] arr = word.toCharArray();\r\n        for (int i = 0; i < word.length(); i++) {\r\n            if (children.containsKey(arr[i])) {\r\n                TrieNode node = children.get(arr[i]);\r\n                current = node;\r\n                children = current.children;\r\n            } else {\r\n                return false;\r\n            }\r\n\r\n        }\r\n        if (current.hashWord == true) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /** Returns if there is any word in the trie that starts with the given prefix. */\r\n    public boolean startsWith(String prefix) {\r\n        TrieNode current = root;\r\n        Map<Character, TrieNode> children = current.children;\r\n        char[] arr = prefix.toCharArray();\r\n        for (int i = 0; i < prefix.length(); i++) {\r\n            if (children.containsKey(arr[i])) {\r\n                TrieNode node = children.get(arr[i]);\r\n                current = node;\r\n                children = current.children;\r\n            } else {\r\n                return false;\r\n            }\r\n\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n * Your Trie object will be instantiated and called as such:\r\n * Trie obj = new Trie();\r\n * obj.insert(word);\r\n * boolean param_2 = obj.search(word);\r\n * boolean param_3 = obj.startsWith(prefix);\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n// *****************************************************原来的版本********************************************************\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// 本质：移动current、children + 一开始map.put\r\nclass TrieNode {\r\n    // 三样东西：1 当前node的字符串 2 children 3 是否找到了word\r\n    //a - z\r\n    char c;\r\n    HashMap<Character, TrieNode> children = new HashMap<>();\r\n    boolean hasWord;\r\n\r\n    public TrieNode() {\r\n    \r\n    }\r\n\r\n    public TrieNode(char c) {\r\n        this.c = c;\r\n    }\r\n    \r\n}\r\npublic class Trie {\r\n\r\n    private TrieNode root;\r\n    /** Initialize your data structure here. */\r\n    public Trie() {\r\n        // root 就是一个空节点，没有实质的意义\r\n        root = new TrieNode();\r\n    }\r\n    \r\n    /** Inserts a word into the trie. */\r\n    public void insert(String word) {\r\n        // *********************注意是root\r\n        TrieNode current = root;\r\n        HashMap<Character, TrieNode> children = current.children;\r\n        char[] wordArray = word.toCharArray();\r\n\r\n        for (int i = 0; i < wordArray.length; i++) {\r\n            char wc = wordArray[i];\r\n            // 1 移动current、children\r\n            if (!children.containsKey(wc)) {\r\n                TrieNode newNode = new TrieNode(wc);\r\n                // 别忘了这步\r\n                children.put(wc, newNode);\r\n                current = newNode;\r\n            } else {\r\n                current = children.get(wc);\r\n            }\r\n            // 当前字母找到了，所以到当前字母的下面去找，即当前字母的children下面找\r\n            children = current.children;\r\n\r\n            // 2 找到了\r\n            if (i == wordArray.length - 1) {\r\n                current.hasWord = true;\r\n            }\r\n            // ***********************没有到最后一个，也不要设置为false，因为可能到了中间某个，单词，\r\n            // 但是这个false是啥意思?记住不能设置false，只能方法返回false，没有找到而已\r\n        }\r\n    }\r\n    \r\n    /** Returns if the word is in the trie. */\r\n    public boolean search(String word) {\r\n            HashMap<Character, TrieNode> children = root.children;\r\n            TrieNode current = null;\r\n            char[] wordArray = word.toCharArray();\r\n    \r\n            for (int i = 0; i < wordArray.length; i++) {\r\n                // 已经有了，移动current、移动children\r\n                if (children.containsKey(wordArray[i])) {\r\n                    current = children.get(wordArray[i]);\r\n                    children = current.children;\r\n                } else {\r\n                    // 没有返回false\r\n                    return false;\r\n                }\r\n            }\r\n    \r\n            // current到了最后,即找到了，因为插入的时候最后一个hasWord是true\r\n            if (current.hasWord){\r\n                return true;    \r\n            } else {\r\n                return false;\r\n            }\r\n    }\r\n    \r\n    /** Returns if there is any word in the trie that starts with the given prefix. */\r\n    public boolean startsWith(String prefix) {\r\n        HashMap<Character, TrieNode> children = root.children;\r\n        TrieNode current = null;\r\n        char[] wordChar = prefix.toCharArray();\r\n        for (int i = 0; i < wordChar.length; i++) {\r\n            // 已经有了，移动current、children\r\n            if (children.containsKey(wordChar[i])) {\r\n                current = children.get(wordChar[i]);\r\n                children = current.children;\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // 全部完了没有返回false就是true，不需要一定找到整个word\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n * Your Trie object will be instantiated and called as such:\r\n * Trie obj = new Trie();\r\n * obj.insert(word);\r\n * boolean param_2 = obj.search(word);\r\n * boolean param_3 = obj.startsWith(prefix);\r\n */
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/note/gupao/15 有序树/01 提示词  [208]/Trie.java b/note/gupao/15 有序树/01 提示词  [208]/Trie.java
--- a/note/gupao/15 有序树/01 提示词  [208]/Trie.java	(revision d68ab86b9d2adf35cf02d32f076be56c407517bf)
+++ b/note/gupao/15 有序树/01 提示词  [208]/Trie.java	(date 1613973064361)
@@ -1,4 +1,4 @@
-// *****************************************************写这个********************************************************
+// *****************************************************写这个2********************************************************
 class TrieNode {
     char c;
     Map<Character, TrieNode> children = new HashMap<>();
